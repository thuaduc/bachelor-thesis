% !TeX root = ../main.tex

\chapter{Introduction}\label{chapter:introduction}

\textbf{Locking mechanism is important.}
In modern computing environments, the efficiency of locking mechanisms is pivotal to the performance of various systems, including databases~\parencite{lomet1993key, graefe2007hierarchical}, file systems~\parencite{lee2021concurrent, gao2023citron, lee2019write}, and operating systems~\parencite{readerWriterLocks2017, mmapSem2017}. The need for more advanced and fine-grained locking mechanisms becomes critical as these systems continue to scale and increase complexity. A key challenge in this context is the management of concurrent access to shared resources. Traditional locking techniques, such as single-lock mechanisms, often introduce significant performance bottlenecks, especially in scenarios with high concurrency, thereby underscoring the necessity for more sophisticated approaches to locking.

\textbf{Range locks boot performance through resource segmentation.} 
Range lock~\parencite{gao2023citron, kogan2020scalable} provides a more refined approach to this challenge by partitioning a shared resource into multiple arbitrary-sized segments. Different processes can exclusively acquire each of these segments. This strategy effectively addresses the drawbacks and bottlenecks associated with single-lock methods, significantly improving the performance.

\textbf{DBMS needs range locks.}
Range locking is crucial in database management systems, particularly for ensuring data consistency and preventing anomalies such as "phantoms" in high-concurrency environments. 
When transactions require strict isolation, as under the serializable isolation level, range locks are used to secure not only the individual records within a specified range but also the gaps between these records. 
This prevents other transactions from inserting new records or modifying existing ones in the Range until the transaction is completed, thereby maintaining the integrity of operations that depend on the stability of a data set. 
Implementing range locks becomes particularly challenging in systems where transaction control (TC) and data control (DC) are separated, as the TC must lock the Range before safely interacting with the DC, despite not knowing the specific keys or records involved. 
Effective range-locking protocols are essential to managing this complexity, ensuring that all relevant resources are locked throughout the transaction to prevent race conditions and maintain consistency across concurrent operations.

\textbf{Filesystem needs range locks.}
In high-performance file systems, particularly those used in large-scale and distributed computing environments, managing concurrent access to shared files is important. As file systems scale to accommodate massive data sets and numerous parallel I/O operations, traditional locking mechanisms often become bottlenecks, reducing throughput and increasing latency. Range locks offer a solution by allowing multiple processes to access different file segments simultaneously without interfering with each other. This segmentation minimizes contention and improves performance by enabling finer-grained locking at the segment level. For file systems handling concurrent access to large files, especially in high-performance computing (HPC) environments, adopting range locks can significantly enhance efficiency and scalability~\parencite{gao2023citron, lee2021concurrent}.

\textbf{Operating system needs range locks.}
There has been growing interest in using range locks within the Linux kernel community. The focus is on using range locks to alleviate contention issues associated with \texttt{mmap\_sem}, a semaphore that manages access to virtual memory areas (VMAs). VMAs represent distinct sections of an application's virtual address space and are organized in a red-black tree. The \texttt{mmap\_sem} semaphore controls access for various operations such as memory mapping, unmapping, protection, and handling page faults. This becomes problematic for data-intensive applications with large, dynamically allocated memory, as contention on this semaphore can become a significant performance bottleneck.

\textbf{Existing range lock needs improvement.}
Previous implementations of range-locking mechanisms often need to improve their performance. These implementations often suffer from contention points due to the reliance on a single lock~\parencite{linuxRangeLockImpl2013, song2013parallelizing}. Additionally, some methods may be complex and tightly coupled with lock-based concurrency control protocols, which are not applicable for general DBMS operations~\parencite{graefe2007hierarchical, andy2022database}. These limitations underscore the need for more refined and scalable solutions that can better handle the demands of modern, large-scale systems.

\textbf{New concurrent range-locking design.} In this research's scope, we propose a new lock-free concurrent range-locking design. We address previous bottleneck issues by leveraging a probabilistic concurrent skip list~\parencite{herlihy2006provably, herlihy2020art} and replace traditional locking by \texttt{compare-and-swap} methods. By doing so, we address the previous range lock bottleneck issues and maintain the lock's high level of performance.

\textbf{Outline of the research.} The scope of this research includes developing and evaluating the proposed range-locking mechanism. We will evaluate focusing on performance under heavy concurrent accesses, ensuring the correctness of data access in overlapping ranges and concurrent operations. Additionally, we will compare the performance of the proposed solution with existing state-of-the-art approaches to provide a comprehensive assessment of its effectiveness.